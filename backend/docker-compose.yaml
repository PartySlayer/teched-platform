services:
  # DATABASE PER AUTH-SERVICE
  db-auth:
    image: postgres:15-alpine
    container_name: db-auth
    environment:
      POSTGRES_DB: auth_db
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    ports:
      - "5433:5432" # Esposto sulla 5433 per non andare in conflitto se hai già Postgres installato

  # DATABASE PER LEARN-SERVICE
  db-learn:
    image: postgres:15-alpine
    container_name: db-learn
    environment:
      POSTGRES_DB: learn_db
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    ports:
      - "5434:5432"

  # DATABASE PER PAYMENT-SERVICE
  db-payment:
    image: postgres:15-alpine
    container_name: db-payment
    environment:
      POSTGRES_DB: payment_db
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    ports:
      - "5435:5432"

  # (Opzionale) MailHog: Un server email finto per testare l'invio dell'OTP
  # Invece di mandare email vere, le vedi in una dashboard web locale
  mailhog:
    image: mailhog/mailhog
    container_name: mailhog
    ports:
      - "1025:1025" # SMTP server
      - "8025:8025" # Dashboard Web

        #Avvio: Apri il terminale nella root del progetto e scrivi: docker compose up -d (Il -d serve per farlo girare in background senza bloccare il terminale).
        #
        #Isolamento: Come vedi, abbiamo tre database separati. Questo è il cuore dei microservizi: se il database di learn si rompe, auth continua a funzionare perfettamente.
        #
        #Porte:
        #
        #All'interno della rete Docker, tutti usano la porta 5432.
        #
        #Dall'esterno (es. se vuoi collegarti con un programma come DBeaver o DataGrip), userai le porte 5433, 5434, 5435 per distinguerli.
      #
      #MailHog: Dato che la tua User Story 1 prevede l'invio di un OTP via email, MailHog è fantastico. Non devi configurare AWS SES subito: basta che il tuo codice mandi la mail a localhost:1025 e la vedrai apparire su http://localhost:8025.

